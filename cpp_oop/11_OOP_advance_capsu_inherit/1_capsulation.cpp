

#include<iostream>
#include "1_capsulation.h"
using namespace std;



/*

封裝
    物件導向中用來實作資訊隱藏的機制，確保物件的安全。其作法為：隱藏不想讓外界碰觸的成員，只公開接受外界存取的成員。

    一般而言，類別開發者為了物件的安全，會把資料成員全部隱藏起來，只公開存取或運算資料成員的函式成員。讓物件資料的修改，完全由函式成員掌控其值的變化，避免物件產生預期外的值。
    成員存取的控制以存取修飾詞宣告的段落為單位。在宣告某一個存取修飾詞之後，另一個存取修飾詞出現之前為一個段落。若都沒有宣告，預設為 private 。
    存取修飾詞：
        private
            只允許本類別中的其他成員存取。

        protected
            允許本類別的子類別存取。

        public
            允許所有類別存取。(用範例解釋存取)
            從開始學物件導向起，一直向同學強調要有開發者與使用者的觀念。存取限制，是開發者用來限制使用者的存取權限。



        當你在開發一個類別的時候（假設為類別Ａ），你是類別Ａ的開發者。在類別Ａ中你有用到（存取)另一個類別的時候（假設為類別Ｂ），你是類別Ｂ的使用者。也就是說，在寫程式的時候，你大部份是身兼開發者與使用者的角色，所以容易混淆。

        類別使用者使用類別的方式有二種：物件與繼承。

        我們在開發的類別中用到 string 類別的時候，我們就是 string 類別的使用者。而我們是怎麼使用 string 類別呢？我們是建了 string 的物件，然後用物件儲存資料，再呼叫成員函式運算資料。這就是以物件方式使用類別，所以只能存取 public 成員。也就是說物件只能存類別中宣告為 public 的成員。

        相對的，當你是類別開發者時。只有要讓物件可以存取的成員，才宣告為 public 。

        本章只討論物件導向中比較常用（通用)的存取機制。關於Ｃ語言專有的 friend 本章不討論。

*/










int main(int argc, char const *argv[])
{

    Circle c1;

    c1.setRadius(10);
    c1.setHeight(20);

    cout<<"Area: "<<c1.getArea()<<endl;
    cout<<"Girth: "<<c1.getGirth()<<endl;
    cout<<"Volume: "<<c1.getVolume()<<endl;

    return 0;
}